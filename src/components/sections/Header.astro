---
/**
 * Header - Navegação principal do STL Festival
 * Inclui: Logo, menu de navegação, menu mobile responsivo
 */

// Links de navegação
const navLinks = [
  { href: '#sobre', label: 'SOBRE' },
  { href: '#lineup', label: 'LINE-UP' },
  { href: '#valley', label: 'VALLEY' },
  { href: '#acessibilidade', label: 'ACESSIBILIDADE' },
  { href: '#translado', label: 'TRANSLADO' },
  { href: '#tirolesa', label: 'TIROLESA' },
]
---

<!-- Skip to main content link -->
<a href="#main-content" class="header-skip-link"> Pular para o conteúdo principal </a>

<header class="header" id="header" role="banner">
  <div class="header-container">
    <!-- Logo -->
    <a href="/" class="header-logo" aria-label="STL Festival - Página inicial">
      <img
        src="/logo/logo-stl.svg"
        alt="STL Festival Logo"
        class="header-logo-img"
        loading="eager"
        decoding="async"
      />
    </a>

    <!-- Menu Desktop -->
    <nav class="header-nav" aria-label="Navegação principal">
      <ul class="header-nav-list">
        {
          navLinks.map(link => (
            <li class="header-nav-item">
              <a href={link.href} class="header-nav-link" data-scroll-to={link.href}>
                {link.label}
              </a>
            </li>
          ))
        }
      </ul>
    </nav>

    <!-- Botão CTA Desktop -->
    <a
      href="https://ipass.com.br/stlfestival"
      class="header-cta-button"
      target="_blank"
      rel="noopener noreferrer"
      aria-label="Comprar ingressos para o STL Festival"
    >
      GARANTA SEU INGRESSO
    </a>

    <!-- Botão Menu Mobile -->
    <button
      class="header-menu-toggle"
      aria-label="Abrir menu de navegação"
      aria-expanded="false"
      aria-controls="mobile-menu"
      id="menu-toggle"
    >
      <span class="header-menu-toggle-icon" aria-hidden="true">
        <span></span>
        <span></span>
        <span></span>
      </span>
    </button>
  </div>

  <!-- Menu Mobile -->
  <nav
    class="header-mobile-menu"
    id="mobile-menu"
    aria-label="Menu de navegação mobile"
    aria-hidden="true"
  >
    <ul class="header-mobile-menu-list">
      {
        navLinks.map(link => (
          <li class="header-mobile-menu-item">
            <a href={link.href} class="header-mobile-menu-link" data-scroll-to={link.href}>
              {link.label}
            </a>
          </li>
        ))
      }
    </ul>
  </nav>
</header>

<script>
  // Toggle menu mobile
  const menuToggle = document.getElementById('menu-toggle')
  const mobileMenu = document.getElementById('mobile-menu')
  const navLinks = document.querySelectorAll('[data-scroll-to]')
  let focusTrapCleanup: (() => void) | null = null

  // Função para fechar menu mobile
  function closeMobileMenu() {
    if (menuToggle && mobileMenu) {
      menuToggle.setAttribute('aria-expanded', 'false')
      mobileMenu.setAttribute('aria-hidden', 'true')
      document.body.classList.remove('menu-open')

      // Limpar focus trap
      if (focusTrapCleanup) {
        focusTrapCleanup()
        focusTrapCleanup = null
      }

      // Retornar focus para o botão toggle
      menuToggle.focus()
    }
  }

  // Função para abrir menu mobile
  function openMobileMenu() {
    if (menuToggle && mobileMenu) {
      menuToggle.setAttribute('aria-expanded', 'true')
      mobileMenu.setAttribute('aria-hidden', 'false')
      document.body.classList.add('menu-open')

      // Ativar focus trap
      focusTrapCleanup = trapFocus(mobileMenu, menuToggle)
    }
  }

  // Focus trap no menu mobile
  function trapFocus(menuElement: HTMLElement, toggleButton: HTMLElement) {
    const focusableElements = menuElement.querySelectorAll(
      'a, button, [tabindex]:not([tabindex="-1"])'
    )
    const firstElement = focusableElements[0] as HTMLElement
    const lastElement = focusableElements[focusableElements.length - 1] as HTMLElement

    function handleTab(e: KeyboardEvent) {
      if (e.key !== 'Tab') return

      if (e.shiftKey) {
        if (document.activeElement === firstElement) {
          e.preventDefault()
          lastElement?.focus()
        }
      } else {
        if (document.activeElement === lastElement) {
          e.preventDefault()
          firstElement?.focus()
        }
      }
    }

    document.addEventListener('keydown', handleTab)
    firstElement?.focus()

    return () => {
      document.removeEventListener('keydown', handleTab)
    }
  }

  // Toggle menu mobile
  if (menuToggle && mobileMenu) {
    menuToggle.addEventListener('click', () => {
      const isExpanded = menuToggle.getAttribute('aria-expanded') === 'true'
      if (isExpanded) {
        closeMobileMenu()
      } else {
        openMobileMenu()
      }
    })
  }

  // Escape key handler
  document.addEventListener('keydown', e => {
    if (e.key === 'Escape' && mobileMenu && mobileMenu.getAttribute('aria-hidden') === 'false') {
      closeMobileMenu()
    }
  })

  // Scroll suave para âncoras
  navLinks.forEach(link => {
    link.addEventListener('click', e => {
      const href = link.getAttribute('href')
      if (href?.startsWith('#')) {
        e.preventDefault()
        const target = document.querySelector(href)
        if (target) {
          const headerHeight = document.getElementById('header')?.offsetHeight || 0
          const targetPosition =
            target.getBoundingClientRect().top + window.pageYOffset - headerHeight

          window.scrollTo({
            top: targetPosition,
            behavior: 'smooth',
          })

          // Fechar menu mobile após clicar em link
          if (mobileMenu && mobileMenu.getAttribute('aria-hidden') === 'false') {
            closeMobileMenu()
          }
        }
      }
    })
  })

  // Fechar menu ao clicar fora
  document.addEventListener('click', e => {
    if (
      mobileMenu &&
      mobileMenu.getAttribute('aria-hidden') === 'false' &&
      !mobileMenu.contains(e.target as Node) &&
      !menuToggle?.contains(e.target as Node)
    ) {
      closeMobileMenu()
    }
  })

  // Scroll detection otimizado com requestAnimationFrame
  let ticking = false
  const scrollThreshold = 50

  function updateHeader() {
    const header = document.getElementById('header')
    const scrolled = window.pageYOffset > scrollThreshold

    if (header) {
      header.classList.toggle('header-scrolled', scrolled)
      // Não definir altura fixa no container - deixar CSS controlar
    }

    ticking = false
  }

  window.addEventListener(
    'scroll',
    () => {
      if (!ticking) {
        requestAnimationFrame(updateHeader)
        ticking = true
      }
    },
    { passive: true }
  )

  // Inicializar estado do header
  updateHeader()

  // Mostrar header apenas após preloader completar
  const header = document.getElementById('header')

  // Verificar se preloader já completou (caso de reduced motion ou reload)
  const checkPreloaderComplete = () => {
    // Se não houver preloader ou se reduced motion, mostrar header imediatamente
    const prefersReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches
    if (prefersReducedMotion) {
      if (header) {
        header.classList.add('header-visible')
      }
      return
    }

    // Escutar evento de preloader completo
    window.addEventListener(
      'preloader-complete',
      () => {
        if (header) {
          // Pequeno delay para transição suave
          setTimeout(() => {
            header.classList.add('header-visible')
          }, 300)
        }
      },
      { once: true }
    )

    // FALLBACK: Se após 5 segundos o preloader não completar, mostrar header
    setTimeout(() => {
      if (header && !header.classList.contains('header-visible')) {
        console.warn('[Header] Fallback: Preloader event not fired, showing header anyway')
        header.classList.add('header-visible')
      }
    }, 5000)
  }

  // Aguardar DOM estar pronto
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', checkPreloaderComplete)
  } else {
    checkPreloaderComplete()
  }
</script>

<style is:global>
  @import '../../styles/header.css';
</style>
